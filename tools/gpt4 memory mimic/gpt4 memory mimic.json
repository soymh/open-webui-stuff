[{"id":"gpt4_memory","user_id":"7e9a40d5-a5d7-461c-81eb-91d1973cab1e","name":"GPT4 Memory Mimic","content":"\"\"\"\ntitle: Memory Enhancement Tool for LLM Web UI\nauthor: https://github.com/mhioi\nversion: 0.0.5\nlicense: MIT\n\"\"\"\n\nimport os\nimport json\nfrom typing import Callable, Any\nimport asyncio\nimport datetime\nfrom pydantic import BaseModel, Field\n\n\nclass MemoryFunctions:\n    def __init__(self, memory_file=\"memory.json\", debug=False):\n        self.memory_file = memory_file\n        self.debug = debug\n        self.memory_data = self.load_memory()\n\n    def load_memory(self):\n        if os.path.exists(self.memory_file):\n            if self.debug:\n                print(f\"Loading memory from {self.memory_file}\")\n            with open(self.memory_file, \"r\") as file:\n                return json.load(file)\n        else:\n            return {}\n\n    def save_memory(self):\n        if self.debug:\n            print(f\"Saving memory to {self.memory_file}\")\n        with open(self.memory_file, \"w\") as file:\n            json.dump(self.memory_data, file, ensure_ascii=False, indent=4)\n\n    def add_to_memory(self, key: str, value: Any):\n        if self.debug:\n            print(f\"Adding to memory: {key} = {value}\")\n        # Ensure that new data does not overwrite the existing memory but updates it\n        if key in self.memory_data and isinstance(self.memory_data[key], list):\n            # Append the new value to the existing list\n            self.memory_data[key].append(value)\n        elif key in self.memory_data:\n            # Convert existing value into list and append value\n            self.memory_data[key] = [self.memory_data[key], value]\n        else:\n            self.memory_data[key] = [value]  # Store new entry as list\n        self.save_memory()\n\n    def retrieve_from_memory(self, key: str):\n        if self.debug:\n            print(f\"Retrieving from memory: {key}\")\n        return self.memory_data.get(key, None)\n\n    def process_input_for_memory(self, input_text: str):\n        return {\"timestamp\": str(datetime.datetime.now()), \"input\": input_text}\n\n    def get_all_memories(self) -> dict:\n        if self.debug:\n            print(\"Retrieving all memories.\")\n        return self.memory_data\n\n    def clear_memory(self):\n        if self.debug:\n            print(\"Clearing all memory entries.\")\n        self.memory_data.clear()\n        self.save_memory()\n        return \"ALL MEMORIES CLEARED!\"\n\n\nclass EventEmitter:\n    def __init__(self, event_emitter: Callable[[dict], Any] = None):\n        self.event_emitter = event_emitter\n\n    async def emit(self, description=\"Unknown state\", status=\"in_progress\", done=False):\n        if self.event_emitter:\n            await self.event_emitter(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"status\": status,\n                        \"description\": description,\n                        \"done\": done,\n                    },\n                }\n            )\n\n\nclass Tools:\n    class Valves(BaseModel):\n        USE_MEMORY: bool = Field(\n            default=True, description=\"Enable or disable memory usage.\"\n        )\n        MEMORY_REFRESH_INTERVAL: int = Field(\n            default=60,\n            description=\"Interval in minutes to refresh and analyze memory data.\",\n        )\n        DEBUG: bool = Field(default=False, description=\"Enable or disable debug mode.\")\n\n    def __init__(self):\n        self.valves = self.Valves()\n        self.memory = MemoryFunctions(debug=self.valves.DEBUG)\n        self.confirmation_pending = False\n\n    async def handle_input(\n        self,\n        input_text: str,\n        user_wants_to_add: bool,\n        llm_wants_to_add: bool,\n        __event_emitter__: Callable[[dict], Any] = None,\n    ) -> str:\n        \"\"\"\n        Summarize user input and enhance responses using memory data.\n\n        :params input_text: The TEXT .\n        :return: The response considering memory data.\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n\n        if self.valves.DEBUG:\n            print(f\"Handling input: {input_text}\")\n\n        await emitter.emit(f\"Analyzing input for memory: {input_text}\")\n\n        if self.valves.USE_MEMORY:\n            memory_info = self.memory.process_input_for_memory(input_text)\n\n            if user_wants_to_add:\n                await emitter.emit(\n                    description=f\"User requested to add to memory: {json.dumps(memory_info, ensure_ascii=False)}\",\n                    status=\"memory_update\",\n                    done=False,\n                )\n                self.memory.add_to_memory(\"user_interaction\", memory_info)\n                return \"added to memory by user's request!\"\n            if llm_wants_to_add:\n                await emitter.emit(\n                    description=f\"The LLM added to memory: {json.dumps(memory_info, ensure_ascii=False)}\",\n                    status=\"memory_update\",\n                    done=False,\n                )\n                self.memory.add_to_memory(\"llm_interaction\", memory_info)\n                return \"added to memory by automatic llm request!\"\n\n            # Automatically add important data\n            important_data_info = {\"example_key\": \"Important data to add\"}\n            self.memory.add_important_data(important_data_info)\n\n            # Update memory if contradictions are found\n            self.memory.update_memory_on_contradiction(\"example_key\", \"Updated value\")\n\n        last_interaction = self.memory.retrieve_from_memory(\"user_interaction\")\n        if last_interaction:\n            await emitter.emit(\n                description=f\"Retrieved memory: {json.dumps(last_interaction, ensure_ascii=False)}\",\n                status=\"memory_retrieval\",\n                done=False,\n            )\n\n        response_message = \"Response generated based on input and memory.\"\n        if last_interaction:\n            response_message += (\n                f\"\\nLast interaction noted at: {last_interaction[-1]['timestamp']}.\"\n            )\n\n        await emitter.emit(\n            status=\"complete\",\n            description=\"Processed input and handled memory operations.\",\n            done=True,\n        )\n\n        if self.valves.DEBUG:\n            print(f\"Response message: {response_message}\")\n\n        return json.dumps({\"response\": response_message}, ensure_ascii=False)\n\n    async def recall_memories(\n        self, __event_emitter__: Callable[[dict], Any] = None\n    ) -> str:\n        \"\"\"\n        Retrieve all stored memories and provide them to the user.\n\n        :return: A structured representation of all memory contents.\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n        await emitter.emit(\n            \"Retrieving all stored memories.\", status=\"recall_in_progress\"\n        )\n\n        all_memories = self.memory.get_all_memories()\n        if not all_memories:\n            message = \"No memory stored.\"\n            if self.valves.DEBUG:\n                print(message)\n            await emitter.emit(\n                description=message,\n                status=\"recall_complete\",\n                done=True,\n            )\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        # Correctly format stored memories contents for readability\n        formatted_memories = json.dumps(all_memories, ensure_ascii=False, indent=4)\n\n        if self.valves.DEBUG:\n            print(f\"All stored memories retrieved: {formatted_memories}\")\n\n        await emitter.emit(\n            description=f\"All stored memories retrieved: {formatted_memories}\",\n            status=\"recall_complete\",\n            done=True,\n        )\n\n        return f\"Memories are : {formatted_memories}\"\n\n    async def clear_memories(\n        self, user_confirmation: bool, __event_emitter__: Callable[[dict], Any] = None\n    ) -> str:\n        \"\"\"\n        Clear all stored memories after user confirmation;ask twice the user for confimation.\n\n        :param user_confirmation: Boolean indicating user confirmation to clear memories.\n        :return: A message indicating the status of the operation.\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n        await emitter.emit(\n            \"Attempting to clear all memory entries.\", status=\"clear_memory_attempt\"\n        )\n\n        if self.confirmation_pending and user_confirmation:\n            self.memory.clear_memory()\n            await emitter.emit(\n                description=\"All memory entries have been cleared.\",\n                status=\"clear_memory_complete\",\n                done=True,\n            )\n            self.confirmation_pending = False\n            return json.dumps(\n                {\"message\": \"All memory entries cleared.\"}, ensure_ascii=False\n            )\n\n        if not self.confirmation_pending:\n            self.confirmation_pending = True\n            await emitter.emit(\n                description=\"Please confirm that you want to clear all memories. Call this function again with confirmation.\",\n                status=\"confirmation_required\",\n                done=False,\n            )\n            return json.dumps(\n                {\"message\": \"Please confirm to clear all memories.\"}, ensure_ascii=False\n            )\n\n        await emitter.emit(\n            description=\"Clear memory operation aborted.\",\n            status=\"clear_memory_aborted\",\n            done=True,\n        )\n        self.confirmation_pending = False\n        return json.dumps(\n            {\"message\": \"Memory clear operation aborted.\"}, ensure_ascii=False\n        )\n\n    async def refresh_memory(self, __event_emitter__: Callable[[dict], Any] = None):\n        \"\"\"\n        Periodically refresh and optimize memory data.\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n        await emitter.emit(\"Starting memory refresh process.\")\n\n        if self.valves.DEBUG:\n            print(\"Refreshing memory...\")\n\n        if self.valves.USE_MEMORY:\n            pass  # Implement any periodic memory cleanup here\n\n        if self.valves.DEBUG:\n            print(\"Memory refreshed.\")\n\n        await emitter.emit(\n            status=\"complete\", description=\"Memory refresh completed.\", done=True\n        )\n\n\n# Example of usage: instantiate Tools and call handle_input, recall_memories, or clear_memories with user queries.\n","specs":[{"name":"clear_memories","description":"Clear all stored memories after user confirmation;ask twice the user for confimation.","parameters":{"type":"object","properties":{"user_confirmation":{"type":"bool","description":"Boolean indicating user confirmation to clear memories."}},"required":["user_confirmation"]}},{"name":"handle_input","description":"Summarize user input and enhance responses using memory data.","parameters":{"type":"object","properties":{"input_text":{"type":"str","description":"input_text"},"user_wants_to_add":{"type":"bool","description":"user_wants_to_add"},"llm_wants_to_add":{"type":"bool","description":"llm_wants_to_add"}},"required":["input_text","user_wants_to_add","llm_wants_to_add"]}},{"name":"recall_memories","description":"Retrieve all stored memories and provide them to the user.","parameters":{"type":"object","properties":{},"required":[]}},{"name":"refresh_memory","description":"Periodically refresh and optimize memory data.","parameters":{"type":"object","properties":{},"required":[]}}],"meta":{"description":"a tool for the llm to mimic the gpt4's memory consideration","manifest":{"title":"Memory Enhancement Tool for LLM Web UI","author":"https://github.com/mhioi","version":"0.0.5","license":"MIT"}},"updated_at":1729108205,"created_at":1729078005}]
