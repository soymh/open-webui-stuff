[{"id":"gpt4_memory","user_id":"7e9a40d5-a5d7-461c-81eb-91d1973cab1e","name":"GPT4 Memory Mimic","content":"\"\"\"\ntitle: Memory Enhancement Tool for LLM Web UI\nauthor: https://github.com/mhioi\nversion: 0.3.0\nlicense: MIT\n\"\"\"\n\nimport os\nimport json\nfrom typing import Callable, Any\nimport asyncio\nimport datetime\nfrom pydantic import BaseModel, Field\n\n\nclass MemoryFunctions:\n    def __init__(self, memory_file=\"memory.json\", debug=False):\n        self.memory_file = memory_file\n        self.debug = debug\n        self.memory_data = self.load_memory()\n        self.tag_options = [\"personal\", \"work\", \"education\", \"life\", \"person\", \"others\"]\n\n    def update_memory_by_index(self, index: int, tag: str, memo: str, by: str):\n        if index in self.memory_data:\n            if tag not in self.tag_options:\n                tag = \"others\"\n\n            # Update the entry\n            self.memory_data[index][\"tag\"] = tag\n            self.memory_data[index][\"memo\"] = memo\n            self.memory_data[index][\"by\"] = by\n            self.memory_data[index][\"last_modified\"] = datetime.datetime.now().strftime(\n                \"%Y-%m-%d_%H:%M:%S\"\n            )\n            self.save_memory()\n            return f\"Memory index {index} updated successfully.\"\n        else:\n            return f\"Memory index {index} does not exist.\"\n\n    def load_memory(self):\n        if os.path.exists(self.memory_file):\n            if self.debug:\n                print(f\"Loading memory from {self.memory_file}\")\n            with open(self.memory_file, \"r\") as file:\n                return json.load(file)\n        else:\n            return {}\n\n    def save_memory(self):\n        if self.debug:\n            print(f\"Saving memory to {self.memory_file}\")\n        with open(self.memory_file, \"w\") as file:\n            json.dump(self.memory_data, file, ensure_ascii=False, indent=4)\n\n    def add_to_memory(self, tag: str, memo: str, by: str):\n        if tag not in self.tag_options:\n            tag = \"others\"\n\n        index = len(self.memory_data) + 1\n        entry = {\n            \"tag\": tag,\n            \"memo\": memo,\n            \"by\": by,\n            \"last_modified\": datetime.datetime.now().strftime(\"%Y-%m-%d_%H:%M:%S\"),\n        }\n        self.memory_data[index] = entry\n        self.save_memory()\n\n    # Other methods remain unchanged...\n    def retrieve_from_memory(self, key: str):\n        if self.debug:\n            print(f\"Retrieving from memory: {key}\")\n        return self.memory_data.get(key, None)\n\n    def process_input_for_memory(self, input_text: str):\n        return {\"timestamp\": str(datetime.datetime.now()), \"input\": input_text}\n\n    def get_all_memories(self) -> dict:\n        if self.debug:\n            print(\"Retrieving all memories.\")\n        return self.memory_data\n\n    def clear_memory(self):\n        if self.debug:\n            print(\"Clearing all memory entries.\")\n        self.memory_data.clear()\n        self.save_memory()\n        return \"ALL MEMORIES CLEARED!\"\n\n\nclass EventEmitter:\n    def __init__(self, event_emitter: Callable[[dict], Any] = None):\n        self.event_emitter = event_emitter\n\n    async def emit(self, description=\"Unknown state\", status=\"in_progress\", done=False):\n        if self.event_emitter:\n            await self.event_emitter(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"status\": status,\n                        \"description\": description,\n                        \"done\": done,\n                    },\n                }\n            )\n\n\nclass Tools:\n    class Valves(BaseModel):\n        USE_MEMORY: bool = Field(\n            default=True, description=\"Enable or disable memory usage.\"\n        )\n        MEMORY_REFRESH_INTERVAL: int = Field(\n            default=60,\n            description=\"Interval in minutes to refresh and analyze memory data.\",\n        )\n        DEBUG: bool = Field(default=False, description=\"Enable or disable debug mode.\")\n\n    def __init__(self):\n        self.valves = self.Valves()\n        self.memory = MemoryFunctions(debug=self.valves.DEBUG)\n        self.confirmation_pending = False\n\n    async def handle_input(\n        self,\n        input_text: str,\n        tag: str,\n        user_wants_to_add: bool,\n        llm_wants_to_add: bool,\n        by: str,\n        __event_emitter__: Callable[[dict], Any] = None,\n    ) -> str:\n        \"\"\"\n        Summarize user input and enhance responses using memory data.\n\n        :params input_text: The TEXT .\n        :returns: The response considering memory data.\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n\n        if self.valves.DEBUG:\n            print(f\"Handling input: {input_text}\")\n\n        await emitter.emit(f\"Analyzing input for memory: {input_text}\")\n\n        if self.valves.USE_MEMORY:\n            # Assume 'by' is determined outside and 'tag' is selected by LLM\n            if tag not in self.memory.tag_options:\n                tag = \"others\"\n\n            if user_wants_to_add:\n                await emitter.emit(\n                    description=f\"User requested to add to memory with tag {tag}\",\n                    status=\"memory_update\",\n                    done=False,\n                )\n                self.memory.add_to_memory(tag, input_text, \"user\")\n                return \"added to memory by user's request!\"\n            elif llm_wants_to_add:\n                await emitter.emit(\n                    description=f\"LLM added to memory with tag {tag}\",\n                    status=\"memory_update\",\n                    done=False,\n                )\n                self.memory.add_to_memory(tag, input_text, \"LLM\")\n                return \"added to memory by LLM's request!\"\n\n        # The remaining logic stays the same.\n\n    async def recall_memories(\n        self, __event_emitter__: Callable[[dict], Any] = None\n    ) -> str:\n        \"\"\"\n        Retrieve all stored memories and provide them to the user.\n\n        :return: A structured representation of all memory contents.\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n        await emitter.emit(\n            \"Retrieving all stored memories.\", status=\"recall_in_progress\"\n        )\n\n        all_memories = self.memory.get_all_memories()\n        if not all_memories:\n            message = \"No memory stored.\"\n            if self.valves.DEBUG:\n                print(message)\n            await emitter.emit(\n                description=message,\n                status=\"recall_complete\",\n                done=True,\n            )\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        # Correctly format stored memories contents for readability\n        formatted_memories = json.dumps(all_memories, ensure_ascii=False, indent=4)\n\n        if self.valves.DEBUG:\n            print(f\"All stored memories retrieved: {formatted_memories}\")\n\n        await emitter.emit(\n            description=f\"All stored memories retrieved: {formatted_memories}\",\n            status=\"recall_complete\",\n            done=True,\n        )\n\n        return f\"Memories are : {formatted_memories}\"\n\n    async def clear_memories(\n        self, user_confirmation: bool, __event_emitter__: Callable[[dict], Any] = None\n    ) -> str:\n        \"\"\"\n        Clear all stored memories after user confirmation;ask twice the user for confimation.\n\n        :param user_confirmation: Boolean indicating user confirmation to clear memories.\n        :return: A message indicating the status of the operation.\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n        await emitter.emit(\n            \"Attempting to clear all memory entries.\", status=\"clear_memory_attempt\"\n        )\n\n        if self.confirmation_pending and user_confirmation:\n            self.memory.clear_memory()\n            await emitter.emit(\n                description=\"All memory entries have been cleared.\",\n                status=\"clear_memory_complete\",\n                done=True,\n            )\n            self.confirmation_pending = False\n            return json.dumps(\n                {\"message\": \"All memory entries cleared.\"}, ensure_ascii=False\n            )\n\n        if not self.confirmation_pending:\n            self.confirmation_pending = True\n            await emitter.emit(\n                description=\"Please confirm that you want to clear all memories. Call this function again with confirmation.\",\n                status=\"confirmation_required\",\n                done=False,\n            )\n            return json.dumps(\n                {\"message\": \"Please confirm to clear all memories.\"}, ensure_ascii=False\n            )\n\n        await emitter.emit(\n            description=\"Clear memory operation aborted.\",\n            status=\"clear_memory_aborted\",\n            done=True,\n        )\n        self.confirmation_pending = False\n        return json.dumps(\n            {\"message\": \"Memory clear operation aborted.\"}, ensure_ascii=False\n        )\n\n    async def refresh_memory(self, __event_emitter__: Callable[[dict], Any] = None):\n        \"\"\"\n        Periodically refresh and optimize memory data.\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n        await emitter.emit(\"Starting memory refresh process.\")\n\n        if self.valves.DEBUG:\n            print(\"Refreshing memory...\")\n\n        if self.valves.USE_MEMORY:\n            pass  # Implement any periodic memory cleanup here\n\n        if self.valves.DEBUG:\n            print(\"Memory refreshed.\")\n\n        await emitter.emit(\n            status=\"complete\", description=\"Memory refresh completed.\", done=True\n        )\n\n    async def update_memory_entry(\n        self,\n        index: int,\n        tag: str,\n        memo: str,\n        by: str,\n        __event_emitter__: Callable[[dict], Any] = None,\n    ) -> str:\n        \"\"\"\n        Update an existing memory entry based on its index.\n\n        :param index: The index of the memory entry to update.\n        :param tag: The tag for the memory entry.\n        :param memo: The memory information to update.\n        :param by: Who is making the update ('user' or 'LLM').\n        :returns: A message indicating the success or failure of the update.\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n\n        if self.valves.DEBUG:\n            print(\n                f\"Updating memory index {index} with tag: {tag}, memo: {memo}, by: {by}\"\n            )\n\n        update_message = self.memory.update_memory_by_index(index, tag, memo, by)\n\n        await emitter.emit(\n            description=update_message, status=\"memory_update\", done=True\n        )\n\n        return update_message\n\n\n# Example of usage: instantiate Tools and call handle_input, recall_memories, or clear_memories with user queries.\n","specs":[{"name":"clear_memories","description":"Clear all stored memories after user confirmation;ask twice the user for confimation.","parameters":{"type":"object","properties":{"user_confirmation":{"type":"bool","description":"Boolean indicating user confirmation to clear memories."}},"required":["user_confirmation"]}},{"name":"handle_input","description":"Summarize user input and enhance responses using memory data.","parameters":{"type":"object","properties":{"input_text":{"type":"str","description":"input_text"},"tag":{"type":"str","description":"tag"},"user_wants_to_add":{"type":"bool","description":"user_wants_to_add"},"llm_wants_to_add":{"type":"bool","description":"llm_wants_to_add"},"by":{"type":"str","description":"by"}},"required":["input_text","tag","user_wants_to_add","llm_wants_to_add","by"]}},{"name":"recall_memories","description":"Retrieve all stored memories and provide them to the user.","parameters":{"type":"object","properties":{},"required":[]}},{"name":"refresh_memory","description":"Periodically refresh and optimize memory data.","parameters":{"type":"object","properties":{},"required":[]}},{"name":"update_memory_entry","description":"Update an existing memory entry based on its index.","parameters":{"type":"object","properties":{"index":{"type":"int","description":"The index of the memory entry to update."},"tag":{"type":"str","description":"The tag for the memory entry."},"memo":{"type":"str","description":"The memory information to update."},"by":{"type":"str","description":"Who is making the update ('user' or 'LLM')."}},"required":["index","tag","memo","by"]}}],"meta":{"description":"a tool for the llm to mimic the gpt4's memory consideration","manifest":{"title":"Memory Enhancement Tool for LLM Web UI","author":"https://github.com/mhioi","version":"0.3.0","license":"MIT"}},"updated_at":1729200088,"created_at":1729078005}]
