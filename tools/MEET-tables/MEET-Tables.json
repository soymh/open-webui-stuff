[{"id":"meet","user_id":"7e9a40d5-a5d7-461c-81eb-91d1973cab1e","name":"Memory Enhancement Tool (MET) -Memories Table","content":"\"\"\"\ntitle: Memory Enhancement Tool for Open WebUI\nauthor: https://github.com/mhioi\nversion: 0.0.1\nlicense: MIT\n\"\"\"\n\nimport json\nfrom typing import Callable, Any\n\nfrom open_webui.apps.webui.models.memories import Memories\nfrom pydantic import BaseModel, Field\n\n\nclass EventEmitter:\n    def __init__(self, event_emitter: Callable[[dict], Any] = None):\n        self.event_emitter = event_emitter\n\n    async def emit(self, description=\"Unknown state\", status=\"in_progress\", done=False):\n        if self.event_emitter:\n            await self.event_emitter(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"status\": status,\n                        \"description\": description,\n                        \"done\": done,\n                    },\n                }\n            )\n\n\nclass Tools:\n    class Valves(BaseModel):\n        USE_MEMORY: bool = Field(\n            default=True, description=\"Enable or disable memory usage.\"\n        )\n        DEBUG: bool = Field(default=True, description=\"Enable or disable debug mode.\")\n\n    def __init__(self):\n        self.valves = self.Valves()\n\n    async def recall_memories(\n        self, __user__: dict, __event_emitter__: Callable[[dict], Any] = None\n    ) -> str:\n        \"\"\"\n        Retrieves all stored memories from the user's memory vault and provide them to the user for giving the best response. Be accurate and precise. Do not add any additional information. Always use the function to access memory or memories. If the user asks about what is currently stored, only return the exact details from the function. Do not invent or omit any information.\n\n        :return: A numeric list of all memories. You MUST present the memorys to the user as text. It is important that all memorys are displayed without omissions. Please show each memory entry in full!\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n\n        user_id = __user__.get(\"id\")\n\n        if not user_id:\n            message = \"User ID not provided.\"\n            await emitter.emit(description=message, status=\"missing_user_id\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        await emitter.emit(\n            description=\"Retrieving stored memories.\",\n            status=\"recall_in_progress\",\n            done=False,\n        )\n\n        user_memories = Memories.get_memories_by_user_id(user_id)\n\n        if not user_memories:\n            message = \"No memory stored.\"\n            await emitter.emit(description=message, status=\"recall_complete\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        content_list = [\n            f\"{index}. {memory.content}\"\n            for index, memory in enumerate(\n                sorted(user_memories, key=lambda m: m.created_at), start=1\n            )\n        ]\n\n        await emitter.emit(\n            description=f\"{len(user_memories)} memories loaded\",\n            status=\"recall_complete\",\n            done=True,\n        )\n\n        return f\"Memories from the users memory vault: {content_list}\"\n\n    async def add_memory(\n        self,\n        input_text: str,\n        __user__: dict,\n        __event_emitter__: Callable[[dict], Any] = None,\n    ) -> str:\n        \"\"\"\n        Add a new entry to the user's memory vault. Always use the function to actually store the data; do not simulate or pretend to save data without using the function. After adding the entry, retrieve all stored memories from the user's memory vault and provide them accurately. Do not invent or omit any information; only return the data obtained from the function. Do not assume that any input text already exists in the user's memories unless the function explicitly confirms that a duplicate entry is being added. Simply acknowledge the new entry without referencing prior content unless it is confirmed by the memory function.\n        - User's name: \"xyz\"\n        - User's age: \"30\"\n        - User's profession: \"programmer specializing in Python\"\"\n\n\n        :params input_text: The TEXT .\n        :returns: A numeric list of all memories.\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n        user_id = __user__.get(\"id\")\n\n        if not user_id:\n            message = \"User ID not provided.\"\n            await emitter.emit(description=message, status=\"missing_user_id\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        await emitter.emit(\n            description=\"Adding entry to the memory vault.\",\n            status=\"add_in_progress\",\n            done=False,\n        )\n\n        new_memory = Memories.insert_new_memory(user_id, input_text)\n\n        if not new_memory:\n            message = \"Failed to add memory.\"\n            await emitter.emit(description=message, status=\"add_failed\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        # Fetch updated memories after addition\n        user_memories = Memories.get_memories_by_user_id(user_id)\n\n        content_list = [\n            f\"{index}. {memory.content}\"\n            for index, memory in enumerate(\n                sorted(user_memories, key=lambda m: m.created_at), start=1\n            )\n        ]\n\n        await emitter.emit(\n            description=f\"Added entry to the memory vault: {content_list}\",\n            status=\"add_complete\",\n            done=True,\n        )\n\n        return f\"Added to the users memory vault; new memories are: {content_list}\"\n","specs":[{"name":"add_memory","description":"Add a new entry to the user's memory vault. Always use the function to actually store the data; do not simulate or pretend to save data without using the function. After adding the entry, retrieve all stored memories from the user's memory vault and provide them accurately. Do not invent or omit any information; only return the data obtained from the function. Do not assume that any input text already exists in the user's memories unless the function explicitly confirms that a duplicate entry is being added. Simply acknowledge the new entry without referencing prior content unless it is confirmed by the memory function.","parameters":{"type":"object","properties":{"input_text":{"type":"str","description":"input_text"}},"required":["input_text"]}},{"name":"recall_memories","description":"Retrieves all stored memories from the user's memory vault and provide them to the user for giving the best response. Be accurate and precise. Do not add any additional information. Always use the function to access memory or memories. If the user asks about what is currently stored, only return the exact details from the function. Do not invent or omit any information.","parameters":{"type":"object","properties":{},"required":[]}}],"meta":{"description":"enhanced version of gpt4 memory mimic","manifest":{"title":"Memory Enhancement Tool for Open WebUI","author":"https://github.com/mhioi","version":"0.0.1","license":"MIT"}},"updated_at":1729826192,"created_at":1729512926}]
